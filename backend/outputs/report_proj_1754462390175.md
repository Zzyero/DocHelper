# 实验报告：冒泡排序与快速排序算法性能对比实验

## 一、实验摘要
本实验通过对比冒泡排序与快速排序算法在不同规模数据集上的执行效率，验证了算法时间复杂度理论。实验结果表明：在处理大规模数据时，快速排序的执行效率显著优于冒泡排序，验证了O(nlogn)与O(n²)时间复杂度的理论差异。实验使用Python 3.9环境，测试数据规模从100到10,000个随机整数。

## 二、实验目的
1. 验证排序算法的时间复杂度理论
2. 对比不同规模数据下两种算法的实际执行效率
3. 理解算法选择对程序性能的影响

## 三、实验环境
- 操作系统：Windows 11
- 编程语言：Python 3.9
- 硬件配置：Intel i5-1135G7, 16GB RAM
- 测试数据：随机生成的整数列表（范围0-10000）

## 四、实验方法
### 4.1 算法实现
```python
# 冒泡排序实现
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# 快速排序实现
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

### 4.2 测试步骤
1. 生成5组不同规模的随机整数列表（100、500、1000、5000、10000个元素）
2. 每组数据重复测试10次，取平均执行时间
3. 使用time模块记录算法执行时间
4. 比较两种算法在不同数据规模下的性能差异

## 五、实验结果
| 数据规模 | 冒泡排序平均时间(s) | 快速排序平均时间(s) |
|---------|-------------------|-------------------|
| 100     | 0.0002            | 0.0001            |
| 500     | 0.0058            | 0.0005            |
| 1,000   | 0.0224            | 0.0011            |
| 5,000   | 0.5682            | 0.0065            |
| 10,000  | 2.2715            | 0.0142            |

## 六、结果分析
1. **时间复杂度验证**：随着数据规模增大，冒泡排序的执行时间呈平方级增长，而快速排序呈线性对数级增长，符合O(n²)与O(nlogn)的理论预期。

2. **性能差距**：当数据规模达到10,000时，冒泡排序耗时约2.27秒，而快速排序仅需0.014秒，性能差距达160倍。

3. **小规模数据表现**：在100个元素的小规模数据中，两种算法性能差异不明显，这解释了为何在某些特定场景下简单算法仍具实用性。

## 七、结论
本实验验证了算法时间复杂度理论在实际应用中的重要性。对于大规模数据处理，应优先选择时间复杂度较低的算法。尽管快速排序实现较复杂，但其在大数据量下的性能优势显著，验证了"选择合适算法"对程序性能的关键影响。在实际开发中，应根据数据规模和应用场景合理选择排序算法。

## 八、思考与改进
1. 可进一步测试不同数据分布（如已排序、逆序、部分有序）对算法性能的影响
2. 可研究快速排序的优化版本（如三数取中法）对性能的提升
3. 在极端情况下（如已排序数据），快速排序可能退化为O(n²)，需考虑混合排序策略

---
*注：本报告为简化示例，实际实验报告应包含更详细的数据分析、图表展示和误差讨论。如需针对特定实验内容定制报告，请提供详细实验数据和要求。*